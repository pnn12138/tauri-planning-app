## 问题分析
在拖拽任务进行重新排序时，UI会先通过`updateKanban`函数进行乐观更新，然后调用`reorderTasks`函数来更新数据库。但`reorderTasks`函数只有在开始执行时才会调用`saveSnapshot`保存快照用于回滚。由于快照是在乐观更新之后保存的，当API调用失败时，`rollback`操作会恢复到已经重新排序的状态，导致UI与数据库不一致。

## 解决方案
采用方案1：在乐观更新前保存快照，并优化相关逻辑以避免双快照问题，统一回滚方式。

## 实现步骤

### 步骤1：修改reorderTasks函数，移除内部的saveSnapshot和rollback逻辑
- 打开 `src/features/planning/planning.store.ts` 文件
- 定位到 `reorderTasks` 函数（第566-584行）
- 移除 `saveSnapshot()` 调用
- 移除 try-catch 块，让错误直接抛出
- 保留后台刷新逻辑

### 步骤2：修改handleDragEnd函数，在乐观更新前保存快照
- 打开 `src/Home.tsx` 文件
- 定位到 `handleDragEnd` 函数中的乐观更新代码（第341-347行）
- 在调用 `updateKanban` 之前添加 `saveSnapshot()` 调用

### 步骤3：统一失败回滚方式
- 在 `handleDragEnd` 函数的catch块中，使用 `rollback()` 进行快速回滚
- 然后异步调用 `loadTodayData()` 确保最终与数据库一致

## 修改前后对比

### 步骤1：修改reorderTasks函数
#### 修改前
```typescript
// Reorder tasks in batch
export async function reorderTasks(tasks: any[]) {
  saveSnapshot();
  
  try {
    await planningApi.planningReorderTasks(tasks);
    // 后台触发一次refreshToday()兜底对齐
    setTimeout(() => {
      const state = getPlanningStoreState();
      if (state.todayData) {
        reloadTodayData(state.todayData.today);
      }
    }, 100);
  } catch (error) {
    rollback();
    handleApiError(error, undefined, '重新排序任务');
  }
}
```

#### 修改后
```typescript
// Reorder tasks in batch
export async function reorderTasks(tasks: any[]) {
  await planningApi.planningReorderTasks(tasks);
  // 后台触发一次refreshToday()兜底对齐
  setTimeout(() => {
    const state = getPlanningStoreState();
    if (state.todayData) {
      reloadTodayData(state.todayData.today);
    }
  }, 100);
}
```

### 步骤2-3：修改handleDragEnd函数
#### 修改前
```typescript
// 先本地更新 UI（乐观更新）
const updatedKanban = {
  ...todayData.kanban,
  [sourceColumnId]: updatedSourceTasks,
  [targetColumnId]: updatedTargetTasks,
};
updateKanban(updatedKanban);

// 批量更新到数据库
try {
  await reorderTasks(tasksToUpdate);
} catch (error) {
  console.error('Failed to reorder tasks:', error);
  alert('排序更新失败，已恢复原顺序');
  // 恢复原始数据
  loadTodayData(yyyymmdd);
}
```

#### 修改后
```typescript
// 保存快照，确保在乐观更新前
saveSnapshot();

// 本地更新 UI（乐观更新）
const updatedKanban = {
  ...todayData.kanban,
  [sourceColumnId]: updatedSourceTasks,
  [targetColumnId]: updatedTargetTasks,
};
updateKanban(updatedKanban);

// 批量更新到数据库
try {
  await reorderTasks(tasksToUpdate);
} catch (error) {
  console.error('Failed to reorder tasks:', error);
  alert('排序更新失败，已恢复原顺序');
  // 先快速回滚到快照状态
  rollback();
  // 再异步重拉数据确保最终一致性
  await loadTodayData(yyyymmdd);
}
```

## 预期效果
1. **快照保存时机正确**：在乐观更新前保存快照，确保快照是排序前的原始状态
2. **避免双快照问题**：移除了reorderTasks内部的saveSnapshot，防止快照被覆盖
3. **统一回滚方式**：失败时先快速回滚，再异步重拉数据，兼顾用户体验和数据一致性
4. **职责边界清晰**：handleDragEnd负责UI层的快照管理和回滚，reorderTasks专注于数据库操作
5. **提高可靠性**：确保拖拽排序失败时UI能正确回滚，与数据库保持一致

## 关键点说明
- 快照由`saveSnapshot()`函数保存，该函数会保存完整的`todayData`，包括`kanban`、`timeline`等关键状态
- `rollback()`函数会恢复到快照状态，包括所有相关的UI状态
- 异步调用`loadTodayData()`确保最终与数据库一致，解决可能存在的快照过期问题
- 移除reorderTasks内部的错误处理，让错误直接传递给调用者，提高了代码的可维护性和一致性