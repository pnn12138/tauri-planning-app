# S2-2 标签/优先级实现规划（修订版）

## 核心修订点
1. **数据库迁移**：添加幂等的ALTER TABLE逻辑，确保旧数据库能升级
2. **契约范围控制**：先从UpdateTaskInput开始，避免影响现有创建流程
3. **枚举序列化统一**：TaskPriority使用统一的serde规则
4. **标签存储规范**：明确空值处理和JSON格式约定
5. **筛选方案**：纯前端实现，不修改后端API

## 实现顺序（更稳更小）

### 阶段A：DB迁移 + 类型打通（不动UI）

#### 1.1 后端实现
- **模型扩展**：
  - 在 `src-tauri/src/domain/planning.rs` 中添加 `TaskPriority` 枚举
    ```rust
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
    #[serde(rename_all = "lowercase")]
    pub enum TaskPriority {
        High,
        Medium,
        Low,
    }
    ```
  - 扩展 `Task` 结构体，添加 `priority`（Option<TaskPriority>）和 `tags`（Option<Vec<String>>）字段
  - 更新 `UpdateTaskInput`，添加 `priority` 和 `tags` 字段（可选）

- **数据库迁移**：
  - 在 `src-tauri/src/repo/planning_repo.rs` 中添加迁移逻辑
    - 使用 `PRAGMA table_info(tasks)` 检查字段是否存在
    - 幂等地执行 ALTER TABLE 添加 `priority` 和 `tags` 字段
  - 更新 `get_today_data`、`get_task_by_id`、`get_task` 方法的查询结果映射
    - `priority` 字段映射：从数据库TEXT转换为TaskPriority枚举
    - `tags` 字段映射：从数据库TEXT（JSON字符串）解析为Vec<String>，失败则降级为空数组
  - 修改 `update_task` 方法，支持优先级和标签参数
    - 标签存储：Vec<String>序列化为JSON字符串，空数组存储为NULL

- **API命令**：
  - 更新 `planning_update_task` 命令的实现

#### 1.2 前端实现
- **类型定义**：
  - 在 `src/shared/types/planning.ts` 中添加 `TaskPriority` 类型
  - 扩展 `Task` 和 `UpdateTaskInput` 接口
  - 更新 `CreateTaskInput` 接口（可选，保持向后兼容）

### 阶段B：优先级UI（先update再create）

#### 2.1 前端实现
- **任务卡片**：
  - 修改 `src/features/planning/TaskCard.tsx`，添加优先级角标显示
  - 有优先级则显示，无则隐藏

- **任务编辑**：
  - 添加任务编辑功能（可通过卡片菜单或弹窗实现）
  - 实现优先级选择器，支持更新任务优先级

#### 2.2 验收标准
- 设置优先级后，任务卡片显示正确的角标
- 重启应用后，优先级仍正确保存

### 阶段C：标签UI（同样先update）

#### 3.1 前端实现
- **标签输入组件**：
  - 实现标签输入组件，支持添加、删除标签
  - 输入→回车添加，点击×删除

- **任务卡片**：
  - 修改 `src/features/planning/TaskCard.tsx`，添加标签展示
  - 最多展示2-3个标签，超出显示"+N"

- **任务编辑**：
  - 在任务编辑功能中添加标签管理

#### 3.2 验收标准
- 添加标签后，任务卡片正确展示
- 重启应用后，标签仍存在
- 标签解析失败时，降级为空数组，不影响页面显示

### 阶段D：前端筛选（纯前端）

#### 4.1 前端实现
- **筛选条组件**：
  - 在 `src/pages/Home.tsx` 顶部添加轻量筛选条
  - 实现标签多选和优先级单选功能
  - 支持清空筛选条件

- **筛选逻辑**：
  - 在前端维护筛选状态
  - 实现纯前端过滤逻辑，基于已获取的今日任务数据
  - 过滤结果实时更新显示

#### 4.2 验收标准
- 选择标签后，只显示匹配的任务
- 选择优先级后，只显示匹配的任务
- 清空筛选条件后，恢复显示所有任务
- 筛选操作无IPC往返，响应迅速

## 详细实现细节

### 数据库迁移实现
```rust
// 在 planning_repo.rs 的 init 方法中添加
fn init(&self) -> Result<(), ApiError> {
    // 现有 CREATE TABLE 逻辑...
    
    // 迁移：添加 priority 字段
    let has_priority = self.conn.query_row(
        "SELECT COUNT(*) FROM pragma_table_info('tasks') WHERE name = 'priority'",
        [],
        |row| row.get(0)
    )? > 0;
    
    if !has_priority {
        self.conn.execute("ALTER TABLE tasks ADD COLUMN priority TEXT", [])?;
    }
    
    // 迁移：添加 tags 字段
    let has_tags = self.conn.query_row(
        "SELECT COUNT(*) FROM pragma_table_info('tasks') WHERE name = 'tags'",
        [],
        |row| row.get(0)
    )? > 0;
    
    if !has_tags {
        self.conn.execute("ALTER TABLE tasks ADD COLUMN tags TEXT", [])?;
    }
    
    // 其他初始化逻辑...
}
```

### 标签存储约定
- **空值处理**：NULL或""视为无标签
- **有值格式**：必须是合法JSON数组，如 `["tag1", "tag2"]`
- **解析失败**：降级为 `[]`，并记录日志
- **存储逻辑**：空数组存储为NULL，避免冗余数据

### 优先级显示设计
- **高优先级**：红色角标 "高"
- **中优先级**：黄色角标 "中"
- **低优先级**：绿色角标 "低"

### 标签显示设计
- **样式**：圆角背景，浅色文字
- **数量限制**：最多显示2-3个标签
- **超出处理**：显示 "+N"，鼠标悬停时显示所有标签

## 注意事项
1. **向后兼容**：所有新字段均为可选，确保旧数据能正常读取
2. **类型安全**：严格校验枚举值和JSON格式
3. **错误处理**：标签解析失败时降级处理，不影响整体功能
4. **性能优化**：前端筛选避免频繁重渲染
5. **用户体验**：筛选操作实时响应，提供清晰的视觉反馈

## 验收总览
1. **优先级功能**：
   - ✅ 数据库中正确存储优先级
   - ✅ 任务卡片显示优先级角标
   - ✅ 重启后优先级保持

2. **标签功能**：
   - ✅ 数据库中正确存储标签
   - ✅ 任务卡片展示标签
   - ✅ 重启后标签保持
   - ✅ 标签解析失败时降级处理

3. **筛选功能**：
   - ✅ 标签筛选：选择标签后只显示匹配任务
   - ✅ 优先级筛选：选择优先级后只显示匹配任务
   - ✅ 清空筛选：恢复显示所有任务
   - ✅ 纯前端实现，响应迅速