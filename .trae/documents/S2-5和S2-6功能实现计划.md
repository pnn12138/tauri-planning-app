# S2-5和S2-6功能实现计划（最终优化版）

## S2-5 UI State 持久化

### S2-5.1 记住筛选条件 + S2-5.2 记住Home布局折叠/视图状态（合并实现）

**核心设计决策**：
1. **统一JSON Blob存储**：使用单个`ui_state`表存储所有UI状态，避免多套逻辑
2. **与Vault强绑定**：使用vault路径的hash作为唯一标识
3. **幂等初始化**：确保旧DB启动不炸
4. **合并更新策略**：避免UI状态互相覆盖
5. **优化UX反馈**：筛选时明确提示用户

**实现思路**：
1. 使用后端`ui_state`表存储所有UI状态，格式为JSON blob
2. 前端维护单一UI状态对象，统一读写
3. 按vault持久化，切换vault后状态独立
4. 筛选同时影响Kanban列和timeline，提供明确反馈
5. 保存策略：debounce 300ms + 合并更新，避免频繁写入和状态覆盖

**Schema设计**：
```sql
CREATE TABLE IF NOT EXISTS ui_state (
    vault_id TEXT PRIMARY KEY,  -- vault路径的hash值
    state_json TEXT NOT NULL,    -- 存储UI状态的JSON blob
    updated_at TEXT NOT NULL     -- 更新时间
);
```

**state_json格式**：
```json
{
  "filters": {
    "tags": ["tag1", "tag2"],
    "priority": "high"
  },
  "layout": {
    "timelineCollapsed": false
  }
}
```

**vault_id定义**：使用canonicalized vault path的SHA256哈希值，确保唯一性和安全性

**实现步骤**：

1. **后端实现**：
   - 在`planning_repo.rs`中添加`ui_state`表的幂等初始化
   - 实现`get_ui_state`和`set_ui_state`方法
   - `set_ui_state`支持合并更新：先读旧state，merge后写回（事务内）
   - 在`planning_service.rs`中封装UI状态服务
   - 添加`planning_get_ui_state`和`planning_set_ui_state`命令

2. **前端实现**：
   - 在`planning.api.ts`中添加对应的API调用函数
   - 在`planning.store.ts`中添加UI状态管理，维护单一`uiState`对象
   - 实现debounce 300ms的保存机制
   - 所有UI状态更新都通过store合并后统一写入
   - 在`Home.tsx`中：
     - 使用store管理筛选条件
     - 添加timeline折叠控件
     - 在timeline顶部显示筛选提示
     - 区分空态文案（无任务vs筛选后无任务）

**涉及文件**：
- `src-tauri/src/repo/planning_repo.rs`
- `src-tauri/src/services/planning_service.rs`
- `src-tauri/src/commands/planning_cmd.rs`
- `src/features/planning/planning.api.ts`
- `src/features/planning/planning.store.ts`
- `src/Home.tsx`

## S2-6 可靠性与可观测性

### S2-6.1 错误码补齐（NotFound / InvalidStateTransition）

**实现思路**：
1. 先实现`NotFound`错误，处理任务不存在的情况
2. 实现`InvalidStateTransition`错误，处理非法状态转换
3. 暂不实现`Conflict`，因为缺乏乐观锁机制
4. 明确错误处理策略，避免UI闪动

**错误处理策略**：
- **NotFound**：toast提示 + 立即从本地列表移除该task + setTimeout(refreshToday, 500ms)后台校准
- **InvalidStateTransition**：toast提示
- **特殊情况**：当有modal打开时，不强制刷新，只提示用户，在modal关闭时刷新

**实现步骤**：

1. **后端实现**：
   - 在`planning_service.rs`中，为每个操作添加任务存在性检查
   - 如果任务不存在，返回`NotFound`错误码
   - 添加状态转换合法性检查，如从done状态无法start
   - 非法状态转换返回`InvalidStateTransition`错误码

2. **前端实现**：
   - 在`planning.store.ts`中，添加对这些错误码的处理
   - 当收到`NotFound`错误时，显示toast提示，立即从本地移除该任务，并延迟500ms刷新数据
   - 当收到`InvalidStateTransition`错误时，显示toast提示
   - 避免在有modal打开时强制刷新

**涉及文件**：
- `src-tauri/src/services/planning_service.rs`
- `src/features/planning/planning.store.ts`

### S2-6.2 后端关键路径结构化日志

**实现思路**：
1. 使用`tracing`和`tracing-subscriber`实现结构化日志
2. 为关键操作创建span，包含必要字段
3. 覆盖所有关键路径：create/start/stop/open_daily/list_today/reorder_tasks
4. 统一日志格式，便于问题定位
5. 添加op_id支持请求级追踪

**实现步骤**：

1. **后端实现**：
   - 添加`tracing`和`tracing-subscriber`依赖
   - 在Tauri入口处（main.rs或lib.rs，取决于项目结构）初始化日志系统
   - 为每个关键操作添加span，包含以下字段：
     - op_id：请求唯一标识
     - task_id：任务ID（如果适用）
     - vault：vault标识
     - elapsed_ms：操作耗时
     - result：操作结果（success/error）
     - error_code：错误码（如果适用）
   - 确保错误情况也有完整的日志记录

**涉及文件**：
- `src-tauri/Cargo.toml`
- `src-tauri/src/main.rs`（或lib.rs，取决于项目结构）
- `src-tauri/src/services/planning_service.rs`
- `src-tauri/src/repo/planning_repo.rs`

## 技术要点

1. **状态持久化**：使用统一JSON blob存储UI状态，与vault强绑定，确保数据一致性
2. **错误处理**：完善的错误码体系，明确的处理策略，提供更好的用户反馈
3. **结构化日志**：使用`tracing`实现字段化日志，包含op_id支持请求级追踪
4. **性能优化**：debounce + 合并更新，避免频繁写入和状态覆盖
5. **用户体验**：明确的筛选反馈，优雅的错误处理，避免UI闪动

## 验收标准

### S2-5 UI State 持久化
- 切换vault后，UI状态不继承
- 筛选条件变化时，300ms后自动保存
- 重启应用后，筛选条件和布局状态保持不变
- 筛选同时影响Kanban列和timeline，提供明确反馈
- 空态文案区分："今天没有排程任务" vs "筛选条件下没有任务"

### S2-6.1 错误码补齐
- 当尝试操作不存在的任务时，返回`NotFound`错误码
- 当前端收到`NotFound`错误时，显示toast提示，立即从本地移除该任务，并延迟500ms刷新
- 当尝试非法状态转换时，返回`InvalidStateTransition`错误码
- 当前端收到`InvalidStateTransition`错误时，显示toast提示
- 有modal打开时，不强制刷新

### S2-6.2 后端关键路径结构化日志
- create/start/stop/open_daily/list_today/reorder_tasks操作都有结构化日志
- 日志包含op_id、task_id、vault、elapsed_ms、result、error_code等关键信息
- 错误情况也有完整的日志记录

## 实现顺序

1. **S2-6.1 NotFound错误码实现**：先解决关键可靠性问题
2. **S2-5 UI State持久化**：一次性实现所有UI状态的持久化，避免多套逻辑
3. **S2-6.2 结构化日志实现**：最后完善可观测性

这样的顺序确保先解决关键的可靠性问题，再提升用户体验，最后完善可观测性。