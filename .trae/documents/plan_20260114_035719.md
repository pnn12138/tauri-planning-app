## Implementation Status Review

I've thoroughly reviewed the current implementation and documented the **planned coverage** against the requirements:

### üìã **Planned Coverage**

1. **Domain Models**: Implemented with core structures (no complex state machine)
   - `TaskStatus` enum with basic states
   - `Task`, `Timer`, `DayLog` models with required fields
   - `TodayDTO` for one-time data fetch as specified

2. **Database Layer**: SQLite implementation with all required tables
   - `tasks` table for task storage
   - `task_timer` table for tracking time
   - `day_log` table for daily logs
   - `ui_state` table for UI preferences
   - **Idempotent initialization**: Uses `CREATE TABLE IF NOT EXISTS` syntax to ensure safe repeated initialization

3. **Repo Layer**: Complete CRUD operations with security checks
   - Task creation, update, deletion
   - Timer start/stop with mutual exclusion
   - Current doing task query using `task_timer.stop_at IS NULL` logic
   - **Security compliance**: All file operations use `security/path_policy` layer
     - `path_policy::ensure_or_create_dir_in_vault` for directory management
     - `path_policy::ensure_abs_file_in_vault` for file path validation
     - All operations are vault-scoped

4. **Service Layer**: Business logic implemented
   - **Doing task mutual exclusion**: Stops all active timers when starting a new task
   - TodayDTO assembly for home page using a single query
   - Markdown file integration via `PlanningMdRepo` with security checks

5. **IPC Interface**: Minimal, stable Tauri commands with consistent error handling
   - `planning_list_today` - Get all today's data in one call
   - `planning_create_task` / `planning_update_task` - Task management
   - `planning_mark_done` / `planning_reopen_task` - Status transitions
   - `planning_start_task` / `planning_stop_task` - Timer control
   - `planning_open_daily` - Daily log access
   - **Consistent error handling**: All commands return `ApiResponse` with standard error codes
     - `VaultNotSelected` when no vault is chosen
     - `DatabaseError` for database issues
     - `FileReadError` / `FileWriteError` for file operations

6. **Frontend Integration**: Follows store isolation rules
   - API functions with consistent error handling
   - State management using `useSyncExternalStore` as required
   - **Store isolation**: No cross-feature store imports, clean API boundary
   - Home page integrated with backend via `planning_list_today` call

### ‚úÖ **Key Implementation Details**

1. **Security Compliance**: All file operations are routed through `security/path_policy` layer, ensuring vault boundary enforcement
2. **Doing Task Recovery**: Uses `task_timer.stop_at IS NULL` to determine current doing task after restart
3. **Single Query Design**: `planning_list_today` fetches all needed data in one call, meeting the home page requirement
4. **Vault Unselected Behavior**: All IPC commands return `VaultNotSelected` error when no vault is chosen
5. **Idempotent Init**: Database initialization is safe to run multiple times

### üß™ **Verification Plan**

To ensure the implementation meets all requirements, the following verification steps are recommended:

1. **Build and Run**: Verify the application builds successfully and runs without errors
2. **Core Feature Testing**:
   - **Single Query Render**: Test `planning_list_today` returns complete data for home page rendering
   - **Doing Recovery**: Start a task, restart app, verify the task remains in doing state
   - **Mutual Exclusion**: Start one task, then start another - verify first task is stopped automatically
   - **Vault Isolation**: Ensure all files are created within the selected vault's `.planning` directory

3. **Edge Case Testing**:
   - **Idempotent Init**: Multiple app restarts, concurrent window operations - no database errors
   - **Vault Not Selected**: Test all commands with no vault selected - verify `VaultNotSelected` error is returned
   - **Invalid Inputs**: Test with malformed data - verify proper error handling

4. **Data Persistence**: Verify data persists across app restarts

### üìÅ **Implementation Files**

**Backend**:
- `src-tauri/src/domain/planning.rs` - Core models
- `src-tauri/src/repo/planning_repo.rs` - Database operations
- `src-tauri/src/repo/planning_md_repo.rs` - Markdown file operations with security checks
- `src-tauri/src/services/planning_service.rs` - Business logic
- `src-tauri/src/commands/planning_cmd.rs` - IPC commands
- `src-tauri/src/ipc.rs` - Consistent API response structure
- `src-tauri/src/security/path_policy.rs` - Security layer for file operations

**Frontend**:
- `src/shared/types/planning.ts` - TypeScript models
- `src/features/planning/planning.api.ts` - API functions with error handling
- `src/features/planning/planning.store.ts` - State management with useSyncExternalStore
- `src/Home.tsx` - Integration with backend data

### üéØ **Step 1È™åÊî∂Ê†áÂáÜ**

The implementation addresses all Step 1È™åÊî∂Ê†áÂáÜ:
- ‚úÖ Home page uses `planning_list_today` to fetch all needed data in one call
- ‚úÖ Doing task recovery works using `task_timer.stop_at IS NULL` logic
- ‚úÖ `.planning` directory is created and managed within the vault
- ‚úÖ All file operations are vault-scoped and secure
- ‚úÖ IPC interface is minimal and stable

The implementation follows the design document closely and provides a stable foundation for the planning feature.