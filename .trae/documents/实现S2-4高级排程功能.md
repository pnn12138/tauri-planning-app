## 优化S2-4高级排程功能实现

### 硬约束规则
1. **时间语义统一**：
   - 统一使用本地时间语义
   - **协议格式**：前后端传输使用 YYYY-MM-DDTHH:mm（无秒、无时区），后端用 chrono::NaiveDateTime 解析；展示按本地格式化
   - 精度到分钟（秒统一为00）

2. **展示优先级规则**：
   - 若scheduled_end存在：显示"End: scheduled_end"（真实结束）
   - 否则若estimate_min存在：显示"Est. end: start + estimate_min"（推算结束）
   - 两者都无：不显示结束时间

### 实现步骤

#### S2-4.1a Timeline展示estimated end（纯前端）
- **目标**：仅当任务已有estimate_min且scheduled_start有值时，在时间轴上展示推算结束时间
- **实现**：
  1. 更新`renderTimelineEvent`函数，添加预计结束时间计算和展示
  2. 实现`calculateEstimatedEnd`工具函数，根据scheduled_start和estimate_min计算结束时间
     - 输入：scheduled_start (YYYY-MM-DDTHH:mm)，estimate_min (分钟数)
     - 输出：estimated_end (YYYY-MM-DDTHH:mm)
     - 计算逻辑：将scheduled_start解析为Date对象，加上estimate_min分钟，再格式化为YYYY-MM-DDTHH:mm
  3. 添加条件判断：仅当scheduled_start && estimate_min时显示
  4. 采用本地时间格式化展示，如"10:30"
- **验收**：有estimate_min且有scheduled_start的任务在时间轴上显示推算结束时间

#### S2-4.2a DB迁移+DTO/Repo支持scheduled_end
- **目标**：为tasks表添加scheduled_end列，支持该字段的读写
- **实现**：
  1. 创建幂等迁移函数：
     - 使用PRAGMA table_info(tasks)判断scheduled_end列是否存在
     - 若不存在则执行：`ALTER TABLE tasks ADD COLUMN scheduled_end TEXT;`
     - 确保重复执行不会报错
  2. 更新`planning_repo.rs`中的row mapping：
     - 读：在row解析中添加scheduled_end字段
     - 写：在INSERT和UPDATE语句中添加scheduled_end字段
  3. 确保旧数据的scheduled_end为NULL
  4. 验证后端DTO和前端类型定义已包含scheduled_end字段
  5. 后端保存前统一格式化scheduled_end为YYYY-MM-DDTHH:mm格式
- **验收**：scheduled_end字段能从DB正确读写，旧数据处理正常

#### S2-4.2b 最小编辑弹窗
- **目标**：在TaskCard的"..."菜单中添加"Edit schedule"弹窗，支持编辑estimate_min和scheduled_end
- **实现**：
  1. 添加任务编辑菜单入口：在TaskCard的"..."菜单中添加"编辑排程"选项
  2. 创建最小化编辑弹窗，包含：
     - estimate_min（数字输入，允许空）
     - scheduled_end（时间选择器，仅当有scheduled_start时可用）
     - 保存/取消按钮
  3. 添加输入校验：
     - estimate_min：若有值，必须是1-1440之间的整数
     - scheduled_end：
       - 日期默认与scheduled_start相同
       - 若end_time < start_time：提示"结束时间不能早于开始时间"并阻止保存
  4. 保存逻辑：
     - 使用现有的`planningUpdateTask`接口，一次性更新两个字段
     - 采用本地时间语义，scheduled_end格式化为YYYY-MM-DDTHH:mm
  5. 保存后UI刷新策略：
     - 成功：调用`refreshToday()`重新获取最新数据，确保timeline显示最新状态
     - 失败：显示错误信息，保持原状态
- **验收**：能通过弹窗编辑estimate_min和scheduled_end，保存后数据持久化且UI实时更新

#### S2-4.2c Timeline展示规则升级
- **目标**：更新时间轴展示规则，优先显示scheduled_end，否则显示推算结束时间
- **实现**：
  1. 修改`renderTimelineEvent`函数，实现展示优先级规则
  2. 确保UI只显示一种结束时间，避免UI噪音
  3. 采用本地时间格式化展示，如"End: 10:30"或"Est. end: 10:30"
- **验收**：scheduled_end优先显示，否则显示推算结束时间，两者都无时不显示

### 实现要点
- 保持MVP原则，优先实现核心功能
- 确保数据持久化和原子更新
- 实现正确的错误处理机制
- 保持类型安全，确保前后端字段一致
- 优化用户体验，确保操作流畅
- 避免过早实现复杂功能（如自动排程/冲突检测）
- 确保所有数据库操作幂等，避免重复执行导致错误
- 严格遵循时间格式协议，避免格式不一致问题

### 验证方式
- S2-4.1a：创建有estimate_min和scheduled_start的任务，检查时间轴是否显示推算结束时间
- S2-4.2a：验证DB迁移成功，scheduled_end字段可正确读写，旧数据处理正常
- S2-4.2b：通过弹窗编辑estimate_min和scheduled_end，保存后数据持久化且UI实时更新
- S2-4.2c：分别创建只有scheduled_end、只有estimate_min、两者都有的任务，检查时间轴展示是否符合规则