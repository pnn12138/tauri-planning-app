## 问题分析

**现象**：触发拖拽后，整列的显示出现异常，任务卡片出现重叠和显示错误。

**根本原因**：
1. **布局结构问题**：SortableTaskCard组件结构设计不当，transform样式应用层级错误
2. **CSS定位冲突**：绝对定位导致拖拽卡片脱离文档流，破坏列布局
3. **间距计算不一致**：`.task-card`的`margin-bottom: 12px`与`.kanban-tasks`的`gap: 8px`冲突
4. **缺少占位元素**：拖拽时没有占位元素保持列布局稳定
5. **视觉反馈不足**：拖拽过程中没有清晰的目标提示和路径反馈

## 修复方案

### 1. 优化组件结构和布局
- 调整SortableTaskCard组件结构，确保transform样式正确应用
- 添加占位元素机制，在拖拽时保持列布局稳定
- 统一卡片间距设置，移除冲突的margin和gap

### 2. 改进CSS定位和视觉效果
- 优化拖拽卡片的定位逻辑，避免脱离文档流
- 改进z-index层级管理，确保拖拽卡片始终可见
- 增强视觉反馈，添加透明度变化、边框动态效果等

### 3. 优化拖拽目标检测
- 增强碰撞检测，确保正确识别时间线目标区域
- 添加任务时间段占用检测，提供清晰的有效/无效提示
- 优化拖拽过程中的性能，减少DOM操作

### 4. 提升用户体验
- 添加明确的拖拽目标高亮
- 优化拖拽路径可视化
- 确保跨设备兼容性，尤其是移动端

## 具体修改点

### 1. 优化SortableTaskCard组件结构
```tsx
const SortableTaskCard = ({ task, columnId }: { task: Task; columnId: string }) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({
    id: task.id,
    data: {
      columnId,
      task,
    },
  });
  
  const style = {
    transform: transform ? CSS.Transform.toString(transform) : undefined,
    transition,
    opacity: isDragging ? 0 : 1, // 拖拽时原位置卡片透明化
    visibility: isDragging ? 'visible' : 'visible',
  };
  
  return (
    <>
      {/* 拖拽占位元素 */}
      {isDragging && (
        <div className="task-card-placeholder">
          {/* 占位内容，保持布局稳定 */}
        </div>
      )}
      {/* 实际拖拽卡片 */}
      <div 
        ref={setNodeRef} 
        style={style} 
        className={`task-card-wrapper ${isDragging ? 'dragging' : ''}`}
        {...attributes}
      >
        {/* 任务卡片内容 - 上部区域可拖拽 */}
        {renderTaskCard(task, listeners)}
      </div>
    </>
  );
};
```

### 2. 优化CSS样式

#### 2.1 修复任务卡片布局
```css
/* 移除gap，使用margin-bottom统一间距 */
.kanban-tasks {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* 优化任务卡片包装器 */
.task-card-wrapper {
  position: relative;
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

/* 移除冗余的margin */
.task-card {
  margin-bottom: 0;
  /* 其他样式保持不变 */
}

/* 拖拽占位元素 */
.task-card-placeholder {
  height: 80px;
  background-color: rgba(59, 130, 246, 0.1);
  border: 2px dashed #3b82f6;
  border-radius: 12px;
  margin-bottom: 8px;
  transition: all 0.2s ease;
}
```

#### 2.2 优化拖拽卡片样式
```css
/* 优化拖拽中卡片的样式 */
.task-card-wrapper.dragging {
  z-index: 1000;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
  opacity: 0.95;
  scale: 1.02;
  pointer-events: none;
  /* 不使用absolute定位，保持在文档流中 */
}

/* 移除可能导致布局问题的绝对定位 */
[data-radix-collection-item] {
  position: relative !important;
}

/* 优化拖拽时的视觉反馈 */
.task-card-wrapper.dragging .task-card {
  border-color: #3b82f6;
  background-color: rgba(255, 255, 255, 0.95);
}
```

#### 2.3 增强拖拽目标反馈
```css
/* 优化时间线拖拽目标样式 */
.timeline-hour-line.dragging-over {
  background-color: rgba(59, 130, 246, 0.2) !important;
  border: 2px dashed #3b82f6 !important;
  border-radius: 6px !important;
  transition: all 0.2s ease;
}

.timeline-hour-line.dragging-over-invalid {
  background-color: rgba(239, 68, 68, 0.2) !important;
  border: 2px dashed #ef4444 !important;
  border-radius: 6px !important;
  transition: all 0.2s ease;
}

/* 优化列拖拽目标样式 */
.kanban-column.dragging-over .kanban-tasks {
  background-color: rgba(59, 130, 246, 0.1);
  border-radius: 8px;
  transition: all 0.2s ease;
}
```

### 3. 优化拖拽逻辑

#### 3.1 增强拖拽状态管理
```typescript
// 在Home组件中添加拖拽状态管理
const [draggingTask, setDraggingTask] = useState<string | null>(null);
const [draggingOverColumn, setDraggingOverColumn] = useState<string | null>(null);
const [draggingOverTimeline, setDraggingOverTimeline] = useState<string | null>(null);

// 优化拖拽开始处理
const handleDragStart = (event: DragStartEvent) => {
  setIsDragging(true);
  setDraggingTask(event.active.id as string);
};

// 优化拖拽移动处理
const handleDragMove = throttle((event: DragMoveEvent) => {
  const { active, over } = event;
  
  // 检测拖拽位置，更新拖拽目标状态
  if (over) {
    if (typeof over.id === 'string' && over.id.startsWith('column:')) {
      setDraggingOverColumn(over.id);
      setDraggingOverTimeline(null);
    } else if (typeof over.id === 'string' && over.id.startsWith('timeline:')) {
      setDraggingOverTimeline(over.id);
      setDraggingOverColumn(null);
    }
  }
}, 50);

// 优化拖拽结束处理
const handleDragEnd = async (event: DragEndEvent) => {
  const { active, over } = event;
  setIsDragging(false);
  setDraggingTask(null);
  setDraggingOverColumn(null);
  setDraggingOverTimeline(null);
  
  // 其他拖拽结束逻辑保持不变
};
```

#### 3.2 增强碰撞检测
```typescript
// 在handleDragEnd中增强碰撞检测
const handleDragEnd = async (event: DragEndEvent) => {
  // ... 现有代码 ...
  
  // 处理时间线拖拽
  if (isOverTimeline) {
    // 从over.id中提取时间信息
    const timeStr = over.id.replace('timeline:', '');
    
    // 验证：检查任务是否有预估时间
    if (!draggedTask.estimate_min) {
      alert('该任务没有预估时间，无法排期');
      return;
    }
    
    // 检查时间段是否被占用
    const isTimeSlotAvailable = checkTimeSlotAvailability(timeStr, draggedTask.estimate_min);
    if (!isTimeSlotAvailable) {
      alert('该时间段已被占用，请选择其他时间段');
      return;
    }
    
    // 其他时间线拖拽逻辑
  }
  
  // ... 现有代码 ...
};

// 检查时间段是否可用
const checkTimeSlotAvailability = (timeStr: string, duration: number): boolean => {
  // 将时间字符串转换为分钟数
  const [hours, minutes] = timeStr.split(':').map(Number);
  const startTime = hours * 60 + minutes;
  const endTime = startTime + duration;
  
  // 检查是否与现有任务重叠
  return !todayData?.timeline.some(task => {
    if (!task.scheduled_start || !task.estimate_min) return false;
    
    const taskStart = parseTimeToMinutes(task.scheduled_start);
    const taskEnd = taskStart + task.estimate_min;
    
    // 检查时间段重叠
    return (startTime < taskEnd) && (endTime > taskStart);
  });
};
```

## 预期效果

1. **布局稳定性**：拖拽时，列布局保持稳定，不会出现卡片重叠或跳跃
2. **清晰的视觉反馈**：
   - 拖拽卡片有明显的视觉变化（阴影、缩放、透明度）
   - 目标区域有清晰的高亮提示
   - 有效/无效目标有不同的视觉反馈
3. **平滑的拖拽体验**：
   - 拖拽过程流畅，没有卡顿
   - 占位元素保持列布局稳定
   - 拖拽结束后，卡片位置更新平滑
4. **准确的拖拽目标检测**：
   - 正确识别时间线目标区域
   - 检测任务时间段占用情况
   - 提供清晰的错误提示
5. **良好的性能表现**：
   - 减少DOM操作和状态更新
   - 事件节流优化
   - 视觉效果流畅不卡顿

这个修复方案综合考虑了布局稳定性、视觉反馈、性能优化和用户体验，确保解决拖拽时整列显示异常的问题，同时提升整体的拖拽体验。