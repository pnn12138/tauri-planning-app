## Summary
This PR refactors tab content to be `tabId`-scoped, so each open Markdown/Web tab owns a stable “content instance” (editor state or webview state) that survives tab switching.

## What changed
- **Editor (Markdown tabs)**
  - `MarkdownTabView({ tabId })` now resolves the tab’s `filePath` via the tab store and resolves `{ content, dirty, mtime... }` via `editorByTab[tabId]`.
  - Introduced `src/features/editor/editor.store.ts` as a real store keyed by `tabId` (`editorByTab`), so switching tabs no longer risks losing editor instances.
  - Added `src/features/editor/editor.api.ts` to unify `read_markdown` / `write_markdown` / `rename_markdown` calls.
  - Preview/editor components were split out (`CodeMirrorEditor`, `PreviewPane`) and wired through `MarkdownTabView`.

- **Web (Web tabs)**
  - Added `src/features/web/web.store.ts` keyed by `tabId` (`webByTab[tabId] = { url, title, loading, canBack, canForward, history... }`).
  - Added `src/features/web/web.actions.ts` to centralize “open / navigate / back / forward / reload” and keep `tab.store` URL/title in sync with `web.store` (Phase 1 simplicity).
  - `src/features/web/bridge.ts` now only bridges events (`webview-state`, `webview-open`) into store updates / actions (no business logic).
  - Implemented `src/features/web/WebTabView.tsx` as the lifecycle owner of webviews (create/show/hide/focus/resize/cleanup), with navigation triggering a controlled instance recreate via `navRevision`.

- **App wiring**
  - `src/App.tsx` now renders `MarkdownTabView` and `WebTabView` by `activeTabId`, consumes `web.store` for loading/back/forward/address UI, and installs the web bridge once in Tauri runtime.
  - Added a small global status store (`src/shared/ui/status.store.ts`) so editor/web can report load/save errors without re-expanding app-level state.

## Why these changes
The task goal is to make “Tab is the content instance host” real in code:
- For Markdown: state must be managed by `tabId` (not by file tree selection), so switching tabs never drops the editor instance and dirty state is correct.
- For Web: webview lifecycle must be owned by a dedicated module to avoid the classic pitfalls (webview losing focus, becoming non-interactive, or being unintentionally destroyed on tab switches). Phase 1 prioritizes a clear lifecycle boundary and basic navigation state over building a full browser.

## Implementation notes
- Web navigation is tracked in `web.store` (`history` + `historyIndex` + derived `canBack/canForward`). When navigation actions occur, `navRevision` increments and `WebTabView` recreates the underlying webview instance to keep behavior consistent and avoid stuck/defocused webviews.
- Bridge updates do **not** mutate UI state directly; they only update stores and/or call actions, keeping the IPC/event surface readable and testable.

This PR was written using [Vibe Kanban](https://vibekanban.com)
